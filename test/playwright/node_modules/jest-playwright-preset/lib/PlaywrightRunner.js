"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const jest_runner_1 = __importDefault(require("jest-runner"));
const utils_1 = require("./utils");
const constants_1 = require("./constants");
const coverage_1 = require("./coverage");
const getBrowserTest = (test, config, browser, wsEndpoint, device) => {
    const { displayName, testEnvironmentOptions } = test.context.config;
    const playwrightDisplayName = utils_1.getDisplayName(browser, device);
    return {
        ...test,
        context: {
            ...test.context,
            config: {
                ...test.context.config,
                testEnvironmentOptions: {
                    ...testEnvironmentOptions,
                    [constants_1.CONFIG_ENVIRONMENT_NAME]: config,
                },
                browserName: browser,
                wsEndpoint,
                device,
                displayName: {
                    name: displayName
                        ? `${playwrightDisplayName} ${typeof displayName === 'string' ? displayName : displayName.name}`
                        : playwrightDisplayName,
                    color: 'yellow',
                },
            },
        },
    };
};
class PlaywrightRunner extends jest_runner_1.default {
    constructor(globalConfig, context) {
        const config = { ...globalConfig };
        // Set default timeout to 15s
        config.testTimeout = config.testTimeout || constants_1.DEFAULT_TEST_PLAYWRIGHT_TIMEOUT;
        super(config, context);
        this.browser2Server = {};
    }
    async getTests(tests, config) {
        const { browsers, devices, launchType, launchOptions } = config;
        let resultDevices = [];
        const pwTests = [];
        for (const test of tests) {
            for (const browser of browsers) {
                utils_1.checkBrowserEnv(browser);
                const { devices: availableDevices, instance } = utils_1.getPlaywrightInstance(browser);
                let wsEndpoint = null;
                if (launchType === constants_1.SERVER) {
                    if (!this.browser2Server[browser]) {
                        const options = utils_1.getBrowserOptions(browser, launchOptions);
                        this.browser2Server[browser] = await instance.launchServer(options);
                    }
                    wsEndpoint = this.browser2Server[browser].wsEndpoint();
                }
                if (devices instanceof RegExp) {
                    resultDevices = Object.keys(availableDevices).filter((item) => item.match(devices));
                }
                else {
                    if (devices) {
                        resultDevices = devices;
                    }
                }
                if (resultDevices.length) {
                    resultDevices.forEach((device) => {
                        if (typeof device === 'string') {
                            const availableDeviceNames = Object.keys(availableDevices);
                            utils_1.checkDeviceEnv(device, availableDeviceNames);
                        }
                        pwTests.push(getBrowserTest(test, config, browser, wsEndpoint, device));
                    });
                }
                else {
                    pwTests.push(getBrowserTest(test, config, browser, wsEndpoint, null));
                }
            }
        }
        return pwTests;
    }
    async runTests(tests, watcher, onStart, onResult, onFailure, options) {
        const { rootDir, testEnvironmentOptions } = tests[0].context.config;
        const config = await utils_1.readConfig(rootDir, testEnvironmentOptions[constants_1.CONFIG_ENVIRONMENT_NAME]);
        const browserTests = await this.getTests(tests, config);
        if (config.collectCoverage) {
            await coverage_1.setupCoverage();
        }
        await (options.serial
            ? this['_createInBandTestRun'](browserTests, watcher, onStart, onResult, onFailure)
            : this['_createParallelTestRun'](browserTests, watcher, onStart, onResult, onFailure));
        for (const browser in this.browser2Server) {
            await this.browser2Server[browser].close();
        }
        if (config.collectCoverage) {
            await coverage_1.mergeCoverage();
        }
    }
}
exports.default = PlaywrightRunner;
