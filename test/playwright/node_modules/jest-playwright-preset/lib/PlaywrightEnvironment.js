"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPlaywrightEnv = void 0;
const constants_1 = require("./constants");
const utils_1 = require("./utils");
const coverage_1 = require("./coverage");
const handleError = (error) => {
    process.emit('uncaughtException', error);
};
const KEYS = {
    CONTROL_C: '\u0003',
    CONTROL_D: '\u0004',
    ENTER: '\r',
};
const getBrowserPerProcess = async (playwrightInstance, browserType, config) => {
    const { launchType, userDataDir, launchOptions, connectOptions } = config;
    if (launchType === constants_1.LAUNCH || launchType === constants_1.PERSISTENT) {
        // https://github.com/mmarkelov/jest-playwright/issues/42#issuecomment-589170220
        if (browserType !== constants_1.CHROMIUM && launchOptions && launchOptions.args) {
            launchOptions.args = launchOptions.args.filter((item) => item !== '--no-sandbox');
        }
        const options = utils_1.getBrowserOptions(browserType, launchOptions);
        if (launchType === constants_1.LAUNCH) {
            return playwrightInstance.launch(options);
        }
        if (launchType === constants_1.PERSISTENT) {
            // @ts-ignore
            return playwrightInstance.launchPersistentContext(userDataDir, options);
        }
    }
    const options = utils_1.getBrowserOptions(browserType, connectOptions);
    return playwrightInstance.connect(options);
};
exports.getPlaywrightEnv = (basicEnv = 'node') => {
    const RootEnv = require(basicEnv === 'node'
        ? 'jest-environment-node'
        : 'jest-environment-jsdom');
    return class PlaywrightEnvironment extends RootEnv {
        constructor(config) {
            super(config);
            this._config = config;
        }
        async setup() {
            const { wsEndpoint, browserName, testEnvironmentOptions } = this._config;
            this._jestPlaywrightConfig =
                testEnvironmentOptions[constants_1.CONFIG_ENVIRONMENT_NAME];
            const { connectOptions, collectCoverage, exitOnPageError, selectors, launchType, debugOptions, } = this._jestPlaywrightConfig;
            if (wsEndpoint) {
                this._jestPlaywrightConfig.connectOptions = {
                    ...connectOptions,
                    wsEndpoint,
                };
            }
            const browserType = utils_1.getBrowserType(browserName);
            let contextOptions = utils_1.getBrowserOptions(browserName, this._jestPlaywrightConfig.contextOptions);
            const device = utils_1.getDeviceType(this._config.device);
            let deviceName = null;
            const { name, instance: playwrightInstance, devices, } = utils_1.getPlaywrightInstance(browserType);
            if (name === constants_1.IMPORT_KIND_PLAYWRIGHT) {
                // eslint-disable-next-line @typescript-eslint/no-var-requires
                const playwright = require('playwright');
                if (selectors) {
                    await Promise.all(selectors.map(({ name, script }) => {
                        return playwright.selectors
                            .register(name, script)
                            .catch((e) => {
                            if (!e.toString().includes('has been already')) {
                                throw e;
                            }
                        });
                    }));
                }
            }
            if (device != null) {
                if (typeof device === 'string') {
                    deviceName = device;
                    contextOptions = { ...devices[device], ...contextOptions };
                }
                else {
                    const { name, ...deviceProps } = device;
                    deviceName = name;
                    contextOptions = { ...deviceProps, ...contextOptions };
                }
            }
            this.global.browserName = browserType;
            this.global.deviceName = deviceName;
            const browserOrContext = await getBrowserPerProcess(playwrightInstance, browserType, this._jestPlaywrightConfig);
            this.global.browser = launchType === constants_1.PERSISTENT ? null : browserOrContext;
            this.global.context =
                launchType === constants_1.PERSISTENT
                    ? browserOrContext
                    : await this.global.browser.newContext(contextOptions);
            if (collectCoverage) {
                ;
                this.global.context.exposeFunction('reportCodeCoverage', coverage_1.saveCoverageToFile);
                this.global.context.addInitScript(() => window.addEventListener('beforeunload', () => {
                    // @ts-ignore
                    reportCodeCoverage(window.__coverage__);
                }));
            }
            this.global.page = await this.global.context.newPage();
            if (exitOnPageError) {
                this.global.page.on('pageerror', handleError);
            }
            this.global.jestPlaywright = {
                _configSeparateEnv: async (config, isDebug) => {
                    let resultBrowserConfig;
                    let resultContextOptions;
                    if (isDebug) {
                        resultBrowserConfig = debugOptions
                            ? utils_1.deepMerge(config, debugOptions)
                            : config;
                        resultContextOptions =
                            debugOptions && debugOptions.contextOptions
                                ? utils_1.deepMerge(config.contextOptions, debugOptions.contextOptions)
                                : config.contextOptions;
                    }
                    else {
                        resultBrowserConfig = utils_1.deepMerge(this._jestPlaywrightConfig, config);
                        resultContextOptions = {
                            ...this._jestPlaywrightConfig.contextOptions,
                            ...config.contextOptions,
                        };
                    }
                    resultBrowserConfig.launchType = constants_1.LAUNCH;
                    const browser = await getBrowserPerProcess(playwrightInstance, browserType, resultBrowserConfig);
                    const newContextOptions = utils_1.getBrowserOptions(browserName, resultContextOptions);
                    const context = await browser.newContext(newContextOptions);
                    const page = await context.newPage();
                    return { browser, context, page };
                },
                resetPage: async () => {
                    const { context, page } = this.global;
                    if (page) {
                        page.removeListener('pageerror', handleError);
                        await page.close();
                    }
                    this.global.page = await context.newPage();
                    if (exitOnPageError) {
                        this.global.page.addListener('pageerror', handleError);
                    }
                },
                resetContext: async (newOptions) => {
                    const { browser, context } = this.global;
                    if (context) {
                        await context.close();
                    }
                    let newContextOptions = contextOptions;
                    if (newOptions) {
                        newContextOptions = { ...newContextOptions, ...newOptions };
                    }
                    this.global.context = await browser.newContext(newContextOptions);
                    await this.global.jestPlaywright.resetPage();
                },
                resetBrowser: async (newOptions) => {
                    const { browser } = this.global;
                    if (browser) {
                        await browser.close();
                    }
                    this.global.browser = await getBrowserPerProcess(playwrightInstance, browserType, this._jestPlaywrightConfig);
                    await this.global.jestPlaywright.resetContext(newOptions);
                    await this.global.jestPlaywright.resetPage();
                },
                debug: async () => {
                    // Run a debugger (in case Playwright has been launched with `{ devtools: true }`)
                    await this.global.page.evaluate(() => {
                        // eslint-disable-next-line no-debugger
                        debugger;
                    });
                    // eslint-disable-next-line no-console
                    console.log('\n\n🕵️‍  Code is paused, press enter to resume');
                    // Run an infinite promise
                    return new Promise((resolve) => {
                        const { stdin } = process;
                        const listening = stdin.listenerCount('data') > 0;
                        const onKeyPress = (key) => {
                            if (key === KEYS.CONTROL_C ||
                                key === KEYS.CONTROL_D ||
                                key === KEYS.ENTER) {
                                stdin.removeListener('data', onKeyPress);
                                if (!listening) {
                                    if (stdin.isTTY) {
                                        stdin.setRawMode(false);
                                    }
                                    stdin.pause();
                                }
                                resolve();
                            }
                        };
                        if (!listening) {
                            if (stdin.isTTY) {
                                stdin.setRawMode(true);
                            }
                            stdin.resume();
                            stdin.setEncoding('utf8');
                        }
                        stdin.on('data', onKeyPress);
                    });
                },
                saveCoverage: async (page) => coverage_1.saveCoverageOnPage(page, collectCoverage),
            };
        }
        async handleTestEvent(event, state) {
            // Hack to set testTimeout for jestPlaywright debugging
            if (event.name === 'add_test' &&
                event.fn &&
                event.fn.toString().includes('jestPlaywright.debug()')) {
                // Set timeout to 4 days
                state.testTimeout = 4 * 24 * 60 * 60 * 1000;
            }
        }
        async teardown() {
            const { browser, context, page } = this.global;
            const { collectCoverage } = this._jestPlaywrightConfig;
            if (page) {
                page.removeListener('pageerror', handleError);
            }
            if (collectCoverage) {
                await Promise.all(context.pages().map((p) => p.close({
                    runBeforeUnload: true,
                })));
                // wait until coverage data was sent successfully to the exposed function
                await new Promise((resolve) => setTimeout(resolve, 10));
            }
            if (browser) {
                await browser.close();
            }
            await super.teardown();
        }
    };
};
exports.default = exports.getPlaywrightEnv();
