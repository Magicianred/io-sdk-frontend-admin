"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatError = exports.readConfig = exports.getSkipFlag = exports.getBrowserOptions = exports.getPlaywrightInstance = exports.getBrowserType = exports.getDeviceType = exports.getDisplayName = exports.checkDeviceEnv = exports.deepMerge = exports.checkBrowserEnv = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const constants_1 = require("./constants");
const fsPromises = fs_1.default.promises;
exports.checkBrowserEnv = (param) => {
    if (param !== constants_1.CHROMIUM && param !== constants_1.FIREFOX && param !== constants_1.WEBKIT) {
        throw new Error(exports.formatError(`Wrong browser type. Should be one of [${constants_1.CHROMIUM}, ${constants_1.FIREFOX}, ${constants_1.WEBKIT}], but got ${param}`));
    }
};
const isObject = (item) => {
    return item && typeof item === 'object' && !Array.isArray(item);
};
exports.deepMerge = (target, source) => {
    let output = { ...target };
    const keys = Object.keys(source);
    if (isObject(target) && isObject(source)) {
        keys.forEach((key) => {
            if (isObject(source[key])) {
                if (!(key in target)) {
                    output = { ...output, [key]: source[key] };
                }
                else {
                    output[key] = exports.deepMerge(target[key], source[key]);
                }
            }
            else {
                output = { ...output, [key]: source[key] };
            }
        });
    }
    return output;
};
exports.checkDeviceEnv = (device, availableDevices) => {
    if (!availableDevices.includes(device)) {
        throw new Error(exports.formatError(`Wrong device. Should be one of [${availableDevices}], but got ${device}`));
    }
};
exports.getDisplayName = (browser, device) => {
    if (device !== null) {
        if (typeof device === 'string') {
            return `browser: ${browser} device: ${device}`;
        }
        if (device.name) {
            return `browser: ${browser} device: ${device.name}`;
        }
    }
    return `browser: ${browser}`;
};
exports.getDeviceType = (device) => {
    const processDevice = process.env.DEVICE;
    if (processDevice) {
        return processDevice;
    }
    return device;
};
exports.getBrowserType = (browser) => {
    const processBrowser = process.env.BROWSER;
    if (processBrowser) {
        return processBrowser;
    }
    return browser || constants_1.CHROMIUM;
};
exports.getPlaywrightInstance = (browserName) => {
    let pw;
    let name;
    try {
        pw = require(`${constants_1.IMPORT_KIND_PLAYWRIGHT}-${browserName}`);
        name = browserName;
    }
    catch (e) {
        try {
            pw = require(constants_1.IMPORT_KIND_PLAYWRIGHT);
            name = constants_1.IMPORT_KIND_PLAYWRIGHT;
        }
        catch (e) {
            throw new Error(exports.formatError(`Cannot find playwright package to use ${browserName}`));
        }
    }
    if (!pw[browserName]) {
        throw new Error(exports.formatError(`Cannot find playwright package to use ${browserName}`));
    }
    return {
        name,
        instance: pw[browserName],
        devices: pw['devices'],
    };
};
const validateConfig = (config) => {
    const renamings = [
        {
            from: 'launchBrowserApp',
            to: 'launchOptions',
        },
        {
            from: 'connectBrowserApp',
            to: 'connectOptions',
        },
        {
            from: 'context',
            to: 'contextOptions',
        },
        {
            from: 'server',
            to: 'serverOptions',
        },
    ];
    const hasError = renamings.some(({ from, to }) => {
        if (from in config) {
            console.warn(exports.formatError(`"${from}" was renamed to "${to}" in version 1.0`));
            return true;
        }
        return false;
    });
    if (hasError) {
        throw new Error(exports.formatError('Validation error occurred'));
    }
};
function getBrowserOptions(browserName, options) {
    let result = options;
    if (result) {
        if (result[browserName]) {
            result = { ...result, ...result[browserName] };
        }
        ;
        [constants_1.CHROMIUM, constants_1.FIREFOX, constants_1.WEBKIT].forEach((browser) => {
            delete result[browser];
        });
        return result;
    }
    return result;
}
exports.getBrowserOptions = getBrowserOptions;
exports.getSkipFlag = (skipOptions, browserName, deviceName) => {
    const { browsers, devices } = skipOptions;
    const isBrowserIncluded = browsers.includes(browserName);
    if (!devices) {
        return isBrowserIncluded;
    }
    else {
        if (devices instanceof RegExp) {
            return isBrowserIncluded && devices.test(deviceName);
        }
        return isBrowserIncluded && devices.includes(deviceName);
    }
};
exports.readConfig = async (rootDir = process.cwd(), jestEnvConfig) => {
    if (jestEnvConfig) {
        return exports.deepMerge(constants_1.DEFAULT_CONFIG, jestEnvConfig);
    }
    const hasCustomConfigPath = !!process.env.JEST_PLAYWRIGHT_CONFIG;
    let fileExtension = 'js';
    if (process.env.npm_package_type === 'module') {
        fileExtension = 'cjs';
    }
    const configPath = process.env.JEST_PLAYWRIGHT_CONFIG ||
        `jest-playwright.config.${fileExtension}`;
    const absConfigPath = path_1.default.resolve(rootDir, configPath);
    let configExists = true;
    try {
        await fsPromises.access(absConfigPath);
    }
    catch (e) {
        configExists = false;
    }
    if (hasCustomConfigPath && !configExists) {
        throw new Error(exports.formatError(`Can't find a root directory while resolving a config file path.\nProvided path to resolve: ${configPath}`));
    }
    if (!hasCustomConfigPath && !configExists) {
        return constants_1.DEFAULT_CONFIG;
    }
    const localConfig = await require(absConfigPath);
    validateConfig(localConfig);
    return exports.deepMerge(constants_1.DEFAULT_CONFIG, localConfig);
};
exports.formatError = (error) => `${constants_1.PACKAGE_NAME}: ${error}`;
